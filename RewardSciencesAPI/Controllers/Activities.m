//
//  Activities.m
//  RewardSciencesAPI
//
//  This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ) on 09/13/2016
//
#import "Activities.h"

@implementation Activities

/**
* This endpoint lets you track the activities your users perform.
* @param    userId    Required parameter: The ID of the user who is performing the activity.
* @param    activityType    Required parameter: The type of activity the user is performing. Example: 'purchased-a-product'
* @param    price    Optional parameter: The price related to the activity, if any. Expressed in USD
* @param    recordId    Optional parameter: The ID for the record associated with the activity in your database.
* @return	Returns the void response from the API call */
- (void) trackAsyncWithUserId:(int) userId
                activityType:(NSString*) activityType
                price:(NSNumber*) price
                recordId:(NSString*) recordId
                completionBlock:(CompletedPostTrack) onCompleted
{
    //validating required parameters
    NSError* _validationError = nil;
    if (activityType == nil)
        _validationError = [[APIError alloc] initWithReason: @"The parameter 'activityType' is a required parameter and cannot be nil."
                                                    andContext:nil];
    if(_validationError != nil)
        onCompleted(NO,nil,nil,_validationError);

    //the base uri for api requests
    NSString* _baseUri = [NSString stringWithString: (NSString*) Configuration_BaseUri];

    //prepare query string for API call
    NSMutableString* _queryBuilder = [NSMutableString stringWithString: _baseUri]; 
    [_queryBuilder appendString: @"/activities"];

    //process optional query parameters
    [APIHelper appendUrl: _queryBuilder withQueryParameters: @{
                    @"user_id": [NSNumber numberWithInteger: userId],
                    @"activity_type": activityType,
                    @"price": (nil != price) ? price : [NSNull null],
                    @"record_id": (nil != recordId) ? recordId : [NSNull null]
                }];

    //validate and preprocess url
    NSString* _queryUrl = [APIHelper cleanUrl: _queryBuilder];

    //preparing request headers
    NSMutableDictionary* _headers = [[NSMutableDictionary alloc] initWithDictionary: @{
        @"user-agent": @"APIMATIC 2.0",
        @"Accept": Configuration_Accept,
        @"Content-Type": Configuration_ContentType,
        @"Authorization": [NSString stringWithFormat:@"Bearer %@", Configuration_OAuthAccessToken]
    }];

    //Remove null values from header collection in order to omit from request
    [APIHelper removeNullValues: _headers];


    //prepare the request and fetch response  
    HttpRequest* _request = [[self clientInstance] post: ^(HttpRequest* _request) 
    { 
        [_request setQueryUrl: _queryUrl]; //set request url        
        [_request setHeaders: _headers]; //set request headers

    }];

    //use the instance of the http client to make the actual call
    [[self clientInstance]
     executeAsString: _request
     success: ^(id _context, HttpResponse *_response) {
         //Error handling using HTTP status codes
         NSError* _statusError = nil;

         //Error handling using HTTP status codes 
         if((_response.statusCode < 200) || (_response.statusCode > 208)) //[200,208] = HTTP OK
             _statusError = [[APIError alloc] initWithReason: @"HTTP Response Not OK"
                                                  andContext:_context];

         if(_statusError != nil)
         {
             //announce completion with failure due to HTTP status code checking
             onCompleted(NO, _context, nil, _statusError);
         }
         else
         {
             //return _response to API caller
             NSString* _strResult = [(HttpStringResponse*)_response body];
             id _result = [NSJSONSerialization
                        JSONObjectWithData: [_strResult dataUsingEncoding: NSUTF8StringEncoding]
                                   options: NSJSONReadingAllowFragments
                                     error: nil];

 
             //announce completion with success
             onCompleted(YES, _context, _result, nil);
         }
     } failure:^(id _context, NSError *_error) {
 
         //announce completion with failure
         onCompleted(NO, _context, nil, _error);
     }];
}


@end